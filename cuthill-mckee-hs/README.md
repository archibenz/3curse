# Cuthill–McKee на Haskell

Проект реализует три схемы переупорядочения вершин графа:

1) Стандартный Cuthill–McKee (CM)
2) Улучшенный Cuthill–McKee (Improved CM, ICM) с псевдопериферийной вершиной (George–Liu)
3) Обратный Cuthill–McKee (RCM) — это обратный порядок ICM

## Сборка и запуск

```bash
cabal build
```

Запуск:

```bash
cabal run cuthill-mckee-hs -- --input sample/graph.txt
```

## Формат входного файла

Файл задаётся списком рёбер (edge list):

```
n m
u v
u v
...
```

- Граф неориентированный, вершины нумеруются 1..n.
- Петли (u == v) игнорируются.
- Повторяющиеся рёбра игнорируются.
- Граф может быть несвязным.

## Описание схем и tie-break правил

### Общие правила
- При обходе BFS соседи добавляются в очередь по возрастанию степени вершины `deg(·)`, при равенстве — по номеру вершины.
- Если граф несвязный, после завершения компоненты выбирается новая стартовая вершина среди непосещённых с минимальной степенью (tie: минимальный номер).

### CM
- Старт: вершина минимальной степени среди непосещённых.
- BFS по правилам сортировки соседей.

### ICM (Improved CM)
- Старт: псевдопериферийная вершина внутри текущей компоненты.
- Псевдопериферия выбирается по George–Liu:
  1. Берём вершину минимальной степени `s0`.
  2. Строим уровни BFS от `s0`.
  3. В последнем уровне выбираем вершину минимальной степени (tie: минимальный номер) — получаем `s1`.
  4. Повторяем, пока эксцентриситет (число уровней − 1) не увеличивается.

### RCM
- Берётся список вершин ICM и разворачивается.

## Пример

```bash
cabal run cuthill-mckee-hs -- --input sample/graph.txt
```

Пример вывода:

```
CM: ...
ICM: ...
RCM: ...
BW_CM: 3
BW_ICM: 2
BW_RCM: 2
```

Ожидаемые значения BW для `sample/graph.txt`:
- BW_CM = 3
- BW_ICM = 2
- BW_RCM = 2
